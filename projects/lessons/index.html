<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Lessons Learned in ML Engineering</title>
    <meta name="description" content="A collection of lessons learned in building machine learning enabled end user applications.">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.e3b97b8d.css" as="style"><link rel="preload" href="/assets/js/app.af06541e.js" as="script"><link rel="preload" href="/assets/js/4.e268ab69.js" as="script"><link rel="preload" href="/assets/js/2.437ece66.js" as="script"><link rel="preload" href="/assets/js/18.1ed267a3.js" as="script"><link rel="preload" href="/assets/js/7.d2df9315.js" as="script"><link rel="prefetch" href="/assets/js/10.8e5eabbe.js"><link rel="prefetch" href="/assets/js/11.46511cb0.js"><link rel="prefetch" href="/assets/js/12.e6d2c8c4.js"><link rel="prefetch" href="/assets/js/13.760babdb.js"><link rel="prefetch" href="/assets/js/14.4f0c167c.js"><link rel="prefetch" href="/assets/js/15.6fce4fc8.js"><link rel="prefetch" href="/assets/js/16.9eb52d74.js"><link rel="prefetch" href="/assets/js/17.a2bb57d9.js"><link rel="prefetch" href="/assets/js/19.a94c2d30.js"><link rel="prefetch" href="/assets/js/20.ce045e5b.js"><link rel="prefetch" href="/assets/js/21.72de4be8.js"><link rel="prefetch" href="/assets/js/22.077f4828.js"><link rel="prefetch" href="/assets/js/23.c5dc8a9c.js"><link rel="prefetch" href="/assets/js/3.e1113467.js"><link rel="prefetch" href="/assets/js/5.11756013.js"><link rel="prefetch" href="/assets/js/6.042e606c.js"><link rel="prefetch" href="/assets/js/8.cb6072d6.js"><link rel="prefetch" href="/assets/js/9.0fc5720e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e3b97b8d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Lessons Learned in ML Engineering</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/projects/lessons/#introduction" class="sidebar-link">Introduction</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/projects/lessons/#terminology" class="sidebar-link">Terminology</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/projects/lessons/#lessons" class="sidebar-link">Lessons</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/projects/lessons/#_1-neural-networks-are-easy-engineering-is-hard" class="sidebar-link">#1: Neural Networks are Easy, Engineering is Hard</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_2-build-the-end-to-end-pipeline-first" class="sidebar-link">#2: Build the End to End Pipeline First</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_3-don-t-underestimate-the-power-of-preprocessing" class="sidebar-link">#3: Don't Underestimate the Power of Preprocessing</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_4-use-jupyter-to-the-fullest-extent" class="sidebar-link">#4: Use Jupyter to the Fullest Extent</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_5-read-research-papers" class="sidebar-link">#5: Read Research Papers</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_6-don-t-sit-around-watching-tensorboard" class="sidebar-link">#6: Don't Sit Around Watching Tensorboard</a></li><li class="sidebar-sub-header"><a href="/projects/lessons/#_7-use-hyper-parameter-optimization" class="sidebar-link">#7: Use Hyper Parameter Optimization</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="hero" data-v-7772bab1><h1 data-v-7772bab1>Lessons Learned in ML Engineering</h1> <div class="image" style="background-image:url(/images/lessons-cover.jpg);" data-v-7772bab1></div> <p data-v-7772bab1>Published: 2019-02-10</p> <p data-v-7772bab1>  Updated: 2020-02-10</p></div> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>This article is a collection of lessons learned in building deep learning based tools, such as Control and Eyetracking. The article is primarily directed at those that are building &quot;real world applications&quot; using deep learning. Here real world means that you need to collect or create a specific dataset unique to your problem, you need to train a network specific to your problem and you need to deploy that network in an application so that it can be moved out of Jupyter.</p> <h2 id="terminology"><a href="#terminology" class="header-anchor">#</a> Terminology</h2> <p>This article assumes some definitions:</p> <ul><li><strong>Recording Application</strong>: code written to collect data for a specific problem. For example, a recording application could collect images from a camera.</li> <li><strong>Trained Network</strong>: a neural network trained on recorded data to make some prediction. For example, classify if this image has a truck in it.</li> <li><strong>Playback Application</strong>: code written to take a trained model and make predictions in a production like environment. For example, a playback application collects images from a camera, then uses a trained network to predict if there is a truck in them.</li> <li><strong>Pipeline</strong>: the collection of tools, applications and scripts that are involved in a machine learning application. For example, the scripts, applications and notebooks required to watch a camera and determine if a truck has pulled up at the loading dock.</li></ul> <h2 id="lessons"><a href="#lessons" class="header-anchor">#</a> Lessons</h2> <h3 id="_1-neural-networks-are-easy-engineering-is-hard"><a href="#_1-neural-networks-are-easy-engineering-is-hard" class="header-anchor">#</a> #1: Neural Networks are Easy, Engineering is Hard</h3> <p>The first lesson you will learn in ML Engineering is that deep learning tasks such as building a neural network are actually surprisingly easy. Thanks to libraries and tools like fast.ai, PyTorch, Pandas, Numpy, SciPy and the many others, the actual act of building and training a network often takes much less time than other parts of the pipeline.</p> <p>Note, this is not to say that building a <em>good</em> model is easy, only the tasks involved in building a model, such as constructing the network data structure, passing it data, training and evaluating is easy because libraries provide all the interfaces necessary to do this quickly. For example, thanks to fast.ai's, you will never need to write a state of the art training loop. With PyTorch's catalog of layers, you will never need to implement a convolution layer or a ReLU node. These components allow quick and easy construction of trained networks. You of course will still need to experiment with architectures and hyperparameters based on your use case.</p> <p>In contrast, building an application to collect and prepare data and use the trained network &quot;in production&quot; will be where 80% of your time goes. This includes tasks like data preparation including exploration, clean up and transformation. This also includes things like deployment with the model behind a web service or integrated in your application. For example, if you are building realtime applications, being able to use a model for rapid predictions will be an added challenge due to their execution time of each forward pass.</p> <h3 id="_2-build-the-end-to-end-pipeline-first"><a href="#_2-build-the-end-to-end-pipeline-first" class="header-anchor">#</a> #2: Build the End to End Pipeline First</h3> <p>Because engineering is hard, you should attempt to minimize the amount of time you put in any one step and focus on building the end to end pipeline first. Get data moving from recording, preprocess, training and playback as soon as possible before improving performance, trying new architectures or trying new techniques. In this scenario, the data doesn't need to be perfect or complete and the trained network doesn't even need to have achieved convergence. This step is solely about making sure the pieces are in place. This is for an important reason: your process of building and training this network and it's parent application are going to require experimentation. Sometimes this will require huge changes to your code. This is exponentially harder to do if you completely built out your end applications before ensuring that the data the application generates is correct and the network that is trained works in your applications.</p> <h3 id="_3-don-t-underestimate-the-power-of-preprocessing"><a href="#_3-don-t-underestimate-the-power-of-preprocessing" class="header-anchor">#</a> #3: Don't Underestimate the Power of Preprocessing</h3> <p>When building your recording application, it may be tempting to record &quot;perfect&quot; data - data that does not need to be preprocessed and can be fed directly into neural network training. Fight the urge to do this. A preprocessing step can save you huge amounts of time by allowing you to offload both cognitive and computing load into a once-in-a-while step. During experimentation, you will almost certainly have to change code somewhere in the recording application. If your recording application needs to run under some constraints like at 60 frames per second, you may need to spend a great deal of time optimizing recording code only to have to rewrite it after realizing that you need to change the way the data is structured. By comparison, a preprocess step doesn't need to be performant, it can be setup to run only once after code is changed. Store data as raw as possible from your recording application and use the preprocess step to enrich it for training.</p> <h3 id="_4-use-jupyter-to-the-fullest-extent"><a href="#_4-use-jupyter-to-the-fullest-extent" class="header-anchor">#</a> #4: Use Jupyter to the Fullest Extent</h3> <p>Jupyter notebooks are traditionally used for data science related tasks, such as data exploration, graphing and small one off tasks. However, the core technology behind Jupyter lets you experiment with any Python code without having to build and run a full application. It's even possible to do full application and library development inside Jupyter, as fast.ai has done and even created the <a href="https://www.fast.ai/2019/12/02/nbdev/" target="_blank" rel="noopener noreferrer">nbdev library<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> for it. Whether you choose to build your whole application in Jupyter or not, use it to experiment and test out functions and classes and do micro benchmarks using the <code>%timeit</code> directive.</p> <h3 id="_5-read-research-papers"><a href="#_5-read-research-papers" class="header-anchor">#</a> #5: Read Research Papers</h3> <p>You may think that because you are building an end user application that your traditional experience in software engineering, such as building Python applications or web based applications will suffice. However, the machine learning process is full of lots of small decisions that add up to be significant. Research papers related to the task you are doing will may give you an idea of which direction to go with your application design that you may otherwise have to discover yourself through experimentation.</p> <h3 id="_6-don-t-sit-around-watching-tensorboard"><a href="#_6-don-t-sit-around-watching-tensorboard" class="header-anchor">#</a> #6: Don't Sit Around Watching Tensorboard</h3> <p>Your training process will output stats during training, such as training and validation loss over the training epochs, either through Jupyter, console or Tensorboard. It may be very tempting to sit and wait for the next epoch to complete to see what the performance looks like in the next step and then the next and the next. You will find yourself wasting a lot of time watching these stats change slowly. Fight the urge to watch the training and instead use your time in other engineering tasks. The final result will be there when it's done.</p> <h3 id="_7-use-hyper-parameter-optimization"><a href="#_7-use-hyper-parameter-optimization" class="header-anchor">#</a> #7: Use Hyper Parameter Optimization</h3> <p>The machine learning process is full of small variables that impact the quality of training and speed. These variables may express themselves differently in combinations with other variables and because running several epochs of a learning cycle can take a lot of time (hours to days, depending on the dataset), you will not be able to manually test each combination to find the best results and will only lose time doing so especially if your data format changes or your network architecture changes. Instead, use a hyper parameter optimization strategy such as Bayesian Optimization, for which Python has an excellent library <a href="https://github.com/fmfn/BayesianOptimization" target="_blank" rel="noopener noreferrer">bayesian-optimization<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.af06541e.js" defer></script><script src="/assets/js/4.e268ab69.js" defer></script><script src="/assets/js/2.437ece66.js" defer></script><script src="/assets/js/18.1ed267a3.js" defer></script><script src="/assets/js/7.d2df9315.js" defer></script>
  </body>
</html>
